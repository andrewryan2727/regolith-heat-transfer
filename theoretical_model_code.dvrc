#Davinci languague: davinci.asu.edu
#used with davinci version 2.17 on Mac



define keff(mars,fk,rc_factor,kgas_factor,sample,cos,Rout,xi,X,zeta,surfenergy, e1,old,ks_const,rc_fixed,rc_fixed_ratio,planet,verbosity,Nc_const,contact_angle_const,labfit,new_fk,suzuki){
if($ARGC==0){
  printf("sphere_diam = $1\n")
  printf("depth = $2\n")
  printf("distance = $3\n")
  printf("mean_porosity = $4\n")
  printf("T = $5\n")
  printf("P = $6\n")
  printf("emiss = $7\n")
  printf("rho = $8   NOT USING ANYMORE...\n")
  printf("gas_type = $9\n")
  printf("options: mars, fk, rc_factor, sample, cos, Rout, xi, X, zeta, e1, surfenergy, old, ks_const, rc_fixed, rc_fixed_ratio, planet,verbosity, Nc_const, contact_angle_const, labfit, new_fk, suzuki\n")
  printf("Samples: glass, sakatani_glass, EMB, tagish, CK, itokawa, glass5, glass10, basalt\n")
  return(null)
}
sphere_diam = double($1)
depth = double($2)
distance = double($3)
mean_porosity = double($4)
T = double($5)
P = double($6)
emiss = double($7)
rho = double($8)
gas_type = $9

if(hasvalue(verbosity)==0){
  verbosity=0
}
if(hasvalue(mars)==0){
  mars = 0
}

if(hasvalue(kgas_factor)==0){
  kgas_factor=1.0
}

if(hasvalue(fk)==0){
  fk = 1.0
}

if(hasvalue(rc_factor)==0){
  rc_factor=1.0
}

if(hasvalue(sample)==0){
  sample="glass"
}

if(hasvalue(cos)==0){
  cos=0
}

if(hasvalue(Rout)==0){
  Rout=1
}

if(hasvalue(old)==0){
  old=0 #this option is to use the old, incorrect formulation of the JKR adhesion. Check your math kids. 
}

if(hasvalue(planet)==0){
  planet="Earth"
}
if(hasvalue(suzuki)==0){
  #This is used to override the default coordination number calcs used in van antwerpen model. Use suzuku correlation instead. 
  suzuki=0
}


if(hasvalue(labfit)==1){
  if(labfit==1){
    #First based on internal lab report to osiris-rex team. Subject to change. 
    zeta = 0.098*sphere_diam^(-0.365)
    xi = 1.885*sphere_diam^(0.310)
    if(verbosity==1){
      printf("Using lab fits for zeta and xi\n")
    }
  }
}

if(hasvalue(new_fk)==0){
  new_fk=0
}

rc_factor = double(rc_factor)

stefan_boltzmann = 5.670367e-8

porosity = porosity(distance,sphere_diam,mean_porosity) #if sphere distance is greater than a few sphere diamters, simply returns porosity
if(suzuki>0){
  Nc = Nc_suzuki(porosity)
} else {
  Nc = Nc(porosity)  
}

if(hasvalue(Nc_const)==1){
  Nc = Nc_const
}

if(hasvalue(contact_angle_const)==1){
  contact_angle = contact_angle_const
} else if(suzuki>0){
  contact_angle = 33.3 #average-ish value
} else {
  contact_angle = contact_angle(Nc)  
}




if(verbosity==1){
printf("Coordination number: %f\n",Nc)
printf("Contact angle: %f\n",contact_angle)
}


if(sample=="glass"){
  poissons = 0.22  #changed from 0.18! Feb 14, 2018
  youngs = 63.e9 #from jaygo sheet
  #surfenergy = (6.67e-5)*T
  ks = ks_glass(T)
  rho_bulk = 2495.0
  #emiss = 0.774462 + 0.000333294*T - (3.25037e-07)*(T^2.)
} else if(sample=="glass10"){
  poissons = 0.22  
  youngs = 63.e9 #from jaygo sheet
  ks = ks_glass10(T)
  rho_bulk = 2570.0
  #emiss = 0.774462 + 0.000333294*T - (3.25037e-07)*(T^2.)
} else if(sample=="glass5"){
  poissons = 0.22  
  youngs = 65.e9 
  ks = ks_glass5(T)
  rho_bulk = 2495.0
  #emiss = 0.774462 + 0.000333294*T - (3.25037e-07)*(T^2.)
} else if(sample=="basalt"){
  poissons = 0.25 #Shultz 1995, via GB 2013
  youngs = 78.e9 #from Shultz 1995, vis GB 2013
#  rho_bulk = 2965.0
  rho_bulk = 3040.0
  #surfenergy = (6.67e-5)*T
  ks = ks_basalt(T)
} else if(sample=="sakatani_basalt"){
  poissons = 0.25 #Shultz 1995, via GB 2013
  youngs = 78.e9 #from Shultz 1995, vis GB 2013
  rho_bulk = 2900.0
  ks = (-9.53e-4)*T + 2.40
} else if(sample=="tagish"){
  ##poissons = 0.30 #Auvray et al 2017 and references therein
  ##youngs = 30.0e9 #Estimate from Bartier and Daniele 2017 and Auvray et al 2017. Could try 40.   
  poissons = 0.269   #from Hildebrand, personal communication
  youngs = 5.625e9  #from Hildebrand, personal communication
  rho_bulk = 1900.0 #Hildebrand, personal communication
  #rho_bulk = 2200.0 #average CM
  #surfenergy = (6.67e-5)*T
  ks = ks_tagish(T) #using CM from Opeil 2010
} else if(sample=="CK"){
  poissons = 0.269   #from Hildebrand, personal communication
  youngs = 5.625e9  #from Hildebrand, personal communication
  rho_bulk = 2675.0 #Using density value from Opeil 2010
  ks = ks_CK(T) #using CK conductivity here instead. Otherwise, same as tagish
} else if(sample=="sakatani_glass" || sample=="FGB"){
  poissons = 0.22
  youngs = 55.1e9
  rho_bulk = 2480.0
  ks = ks_glass_sakatani(T)
  #emiss = 0.89
}  else if(sample=="EMB"){
  poissons = 0.22
  youngs = 55.1e9
  rho_bulk = 2600.0
  ks = (5.10e-4)*T + 1.406
  #emiss = 0.89
} else if(sample=="itokawa"){
  poissons = 0.25 #gundlach and blum
  youngs = 78.e9 #gundlach and Blum
  rho_bulk = 3220.0 #Average LL chondrite, Consolmagno 2008
  ks = 1.40 #Valid at 200-300 K, based on porosity fit from Opeil 2012, assuming LL meteorite mean 8.2% porosity
} else if(sample=="eros" || sample=="Eros"){
  poissons = 0.25 #gundlach and blum
  youngs = 78.e9 #gundlach and blum
  rho_bulk = 3220.0 #Average LL chondrite, Consolmagno 2008
  ks = 1.40 #Valid at 200-300 K, based on porosity fit from Opeil 2012, assuming LL meteorite mean 8.2% porosity
} else if(sample=="ottawa"){
  poissons = 0.08 #Edrogan et al., 2017
  youngs = 1.10e11 #Edrogan et al., 2017
  rho_bulk = 2650.0
  ks = ks_ottawa(T)
} else {
  printf("Invalid sample type!\n")
  return(null)
}


rho = rho_bulk*(1.0-porosity)

if(verbosity==1){
printf("Sample: %s\n",sample)
printf("Planet: %s\n",planet)
}

if(hasvalue(surfenergy)==0){
  surfenergy = 0.020
}

if(hasvalue(ks_const)==1){
  ks = ks_const
}

Fmech = Fmech(depth,rho,sphere_diam/2.,Nc,porosity,planet) #dissertation fmech
Fmech2 = Fmech2(depth,rho,sphere_diam/2.0,porosity,planet) #Sakatani Fmech
rc = rc_jkr(sphere_diam/2.0,Fmech2,surfenergy,poissons,youngs,old=old)
rc = rc*rc_factor

Fmech2 = Fmech2(depth,rho,sphere_diam/2.0,porosity,planet)
rc_sakatani = rc_jkr(sphere_diam/2.0,Fmech2,surfenergy,poissons,youngs)


if(hasvalue(rc_fixed)==1){
  rc = rc_fixed
  rc_sakatani = rc_fixed
}
if(hasvalue(rc_fixed_ratio)==1){
  rc = (sphere_diam/2.0)*rc_fixed_ratio
  rc_sakatani = (sphere_diam/2.0)*rc_fixed_ratio
}

#rc = rc(depth,sphere_diam,youngs)
gamma = rc/(sphere_diam/2.0)
if(verbosity==1){
printf("Contact radiusx100: %f\n",rc*100.0)
printf("Relative radius: %f\n",gamma)
}

omega0 = omega_nought(rc,sphere_diam)
#omega0 = 0.0
Rin12 = Rin12(sphere_diam,rc,omega0,ks)
if((distance/sphere_diam)<=0.5){
  #Wall region!
  k_aluminum = 200.0 #W/m/K
  ks_star = (2.0*ks*k_aluminum)/(ks + k_aluminum)
  printf("Near wall. ks* is %f\n",ks_star)
  R_hertz12 = R_hertz12(ks_star,rc)
  Rin12 = Rin12/2.0
  wall=1
} else {
  R_hertz12 = R_hertz12(ks,rc)
  wall=0
}


if(verbosity==1){
printf("R_hertz12: %f\n",R_hertz12)
printf("Rin12: %f\n",Rin12)
}

mfp = mfp(gas_type,T,P)

rlambda = rlambda(sphere_diam,omega0,mfp)
if(verbosity==1){
printf("rlambda: %f\n",rlambda)
}
no_gas = 1
if(rlambda==0){
  #rlambda was undefined. Pressure is so low that there won't be any gas conduction. 
  rlambda = sphere_diam/2.0
  no_gas = 1

#  Rj = R_hertz12 + Rin12
} else if(rlambda>(sphere_diam/2.0)){
  #pressure is low enough that the entire inter-sphere space is dominated by the smocholowski effect. In other words, max diam is <10 mfp's
  rlambda = sphere_diam/2.0
}

kg = k0(gas_type,T)  

if(no_gas<1 && mars<1){

  
  if(gas_type=="N2"){
    M_gas = 28.013
    Mstar = M_gas*1.4 #if gas is dia/polyatomic. Otherwise, Mstar = M_gas
    Pr = 0.69 #N2 prandlt number
    cpcv = 1.40 #ratio of specific heat for nitrogen
  } else if(gas_type=="CO2"){
    M_gas = 44.01
    Mstar = M_gas*1.4
    Pr = 0.71
    cpcv = 1.30
  } else {
    printf("Unsupported gas type\n")
  }
  M_glass = 526.45 #pyrex molecular mass
  um = M_gas/M_glass
  T0 = 273.15
  aTj = exp(-0.57*((T - T0)/T0))*(Mstar/(6.8 + Mstar)) + ((2.4*um)/((1+um)^2))*(1.0 - exp(-0.57*((T - T0)/T0)))
  aTj[where aTj>1.0] = 1.0

  
  j = (2.0*((2.0-aTj)/aTj)*(2.0*cpcv/(1+cpcv))*(mfp/Pr))
  j[where j<0.0] = 0.0
 
  A_lambda = sphere_diam + j - omega0
  B_lambda = sqrt((sphere_diam/2.0)^2 - rlambda^2)
  C_lambda = sqrt((sphere_diam/2.0)^2 - rc^2)


  Rlambda = 2.0/(3.14159*kg*(A_lambda*ln(((A_lambda - 2.0*B_lambda)/(A_lambda-2.0*C_lambda)))+2.0*B_lambda - 2.0*C_lambda))
  if(verbosity==1){
  printf("j: %f\n",j)
  printf("aTj: %f\n",aTj)
  printf("ABC %f %f %f\n",A_lambda,B_lambda,C_lambda)
  printf("Rlambda: %f\n",Rlambda)
  }

  Rlambda[where Rlambda<0.0] = 0.0


  AG = sphere_diam - omega0
  BG = sqrt((sphere_diam/2.0)^2 - rlambda^2)
  RG = 2.0/(3.14159*kg*(AG*ln((AG/(AG - 2.0*BG)))-2*BG))
  

  Rmid12 = (sphere_diam - omega0)/(ks*3.14159*(rlambda^2 - rc^2))
  if(verbosity==1){
  printf("RG: %f\n",RG)
  printf("Rmid12: %f\n",Rmid12)
  }

  Aout = (sphere_diam/2.0) - 2.0*(0.5*omega0 + 5.0*mfp)
  Bout = sqrt((sphere_diam/2.0)^2 - rlambda^2)


} else {

  Rlambda = 0.0
  Rmid12 = 0.0

  if(mars>0){
    printf("Calculating Rgas for mars\n")
    AG = sphere_diam - omega0
    BG = sqrt((sphere_diam/2.0)^2 - rc^2)

    printf("AG, BG: %f %f\n",AG,BG)

    kgas = k_gas("N2",T,P,sphere_diam,mean_porosity)#*kgas_factor
    printf("Mars k_gas: %f\n",kgas)
    RG = 2.0/(3.14159*kgas*(AG*ln((AG/(AG - 2.0*BG)))-2*BG))
    printf("Mars R_gas = %f\n",RG)
  } else {
    RG = 0.0
  }



  
  Aout = double((sphere_diam/2.0))
  Bout = double(sqrt((sphere_diam/2.0)^2 - rc^2))
  if(verbosity==1){
  printf("Aout Bout %f %f %f\n",Aout,Bout,(Aout-Bout)*1000000)
  }
}

  ####temporary override
  Aout = double((sphere_diam/2.0))
  Bout = double(sqrt((sphere_diam/2.0)^2 - rc^2))
  #if(Aout-Bout ==  0.0){
  #  Bout = Aout - 1.0e-15
  #}
  ####
  
  Rout12 = ln(((Aout + Bout)/(Aout - Bout)))/(ks*3.14159*Bout)
  if(wall==1){
    Rout12 = Rout12*0.5
  }
  #Rout12 = 0.0
  if(verbosity==1){
  printf("Rout12: %f\n",Rout12)
  }

  R_hertz12 = 1.0/R_hertz12

  if(Rlambda>0){
    Rlambda = 1.0/Rlambda
  }
  if(RG>0){
    RG = 1.0/RG
  } 
  Rin12 = 1.0/Rin12
  if(Rmid12>0){
    Rmid12 = 1.0/Rmid12
  }

  if(Rout==1){
    Rout12 = 1.0/Rout12
  } else {
    Rout12 = 0.0
  }



Rj = ((R_hertz12 + Rlambda + RG)^(-1.0)) + ((Rin12 + Rmid12 + Rout12)^(-1.0))

if(verbosity==1){
printf("Rj is %f\n",Rj)
}

if(wall==0){
  kgce_vector = (sphere_diam - omega0)/((sphere_diam^2.0)*Rj)
  if(cos==0){
    kgce = Nc*((sphere_diam - omega0)/(2.0*(sphere_diam^2.0)*Rj))*sin(contact_angle*3.14159/180.)
    kgce_contact = (Nc/(2.0*(sphere_diam^2.0)*(1.0/R_hertz12)))*sin(contact_angle*3.14159/180.)
  } else {
    kgce = Nc*((sphere_diam - omega0)/(2.0*(sphere_diam^2.0)*Rj))*cos(contact_angle*3.14159/180.)
    kgce_contact = (Nc/(2.0*(sphere_diam^2.0)*(1.0/R_hertz12)))*cos(contact_angle*3.14159/180.)
  }

} else {
  kgce_vector = ((sphere_diam/2.0) - omega0)/((sphere_diam^2.0)*Rj)
  kgce = (((sphere_diam/2.0) - omega0)/((sphere_diam^2.0)*Rj))
}

if(verbosity==1){
printf("kgce_vector= %f\n",kgce_vector)
printf("kgce = %f\n",kgce)
}

#Siu and Lee, 2000 "Eô°ffective conductivity computation of a packed bed using constriction resistance and contact angle effects"
#These values only valid for simple cubic!
NL = 1.0/sphere_diam
NA = 1.0/(4.0*(sphere_diam/2.0)^2.0)
Nt = 1.0
beta = 180.0 #cubic

#These values are for BCC
NL = sqrt(3.0)/(sphere_diam)
NA = 3.0/(16.0*(sphere_diam/2.0)^2.0)
Nt = 4.0
beta = 70.53 #BCC

#These values are for FCC
NL = 1.0/(sqrt(2.0)*sphere_diam/2.0)
NA = 1.0/(4.0*(sphere_diam/2.0)^2.0)

#NA = 1.0/(2.0*sqrt(3.0)*(sphere_diam/2.0)^2.0)
#NA = 2.0/(16*(sphere_diam/2.0)^2.0)
#NL = sqrt(2.0)/(2.0*sphere_diam)
NL = sqrt(3.0/8.0)/(sphere_diam/2.0)
NA = 1.0/(2.0*sqrt(3.0)*(sphere_diam/2.0)^2.0)
Nt = 4.0
beta = 90.0 #FCC


R180 = (0.54038/(ks*(sphere_diam/2.0)*gamma))*(1.0 + 1.92069*gamma - 9.158530*gamma^2 + 17.5257*gamma^3.0)
#R_beta = R180 + (0.64*sin(0.5*contact_angle*3.14159/180.0)^2.0 - 0.08*sin(0.5*contact_angle*3.14159/180.0) - 0.56)*ks*(sphere_diam/2.0)
R_beta = R180 + (0.64*sin(beta*3.14159/180.0)^2.0 - 0.08*sin(beta*3.14159/180.0) - 0.56)*ks*(sphere_diam/2.0)
if(verbosity==1){
printf("R180: %f\n",R180)
printf("Rbeta: %f\n",R_beta)
}
keff_siu180 = (NA/NL)*(Nt/R180)
keff_siu = (NA/NL)*(Nt/R_beta)
if(verbosity==1){
printf("Siu keff180: %f\n",keff_siu180)
printf("Siu keff: %f\n",keff_siu)
}

#kgce2 = Nc*((sphere_diam - omega0)/(2.0*(sphere_diam^2.0)*R180))*sin(contact_angle*3.14159/180.)

#Sakatani solid conductivity
C = Nc_suzuki(porosity)
if(hasvalue(Nc_const)==1){
  C = Nc_const
}


if(hasvalue(xi)==0){
  xi = 0.60
}
if(wall==1){
  C = Nc
}
#Values for xi from Sakatani et al., 2017
#Solutions for surf energ = 0.0; depth = 1.0cm
#phi = 0.40; poisson=0.22; emiss = 0.9; youngs = 55.1; ks = 0.855; sample_rho = 1488.0
#710-1000 um: 0.34-0.83
#355-500 um: 0.30-0.65
#180-250 um: 0.36-0.46
#90-106 um: 0.36-0.44
#53-63 um: 0.29-0.33
#emb powder 5 um: ~1
#This is the basic forumation from the paper
#k_sakatani=(4.0/(3.14159^2))*ks*(1.0-porosity)*C*xi*rc_sakatani/(sphere_diam/2.0)

#If we want to include Hs (equation 14), then we must use this version:
Hs = ((4.0*3.14159/3.0)^(1.0/3.0))*(sphere_diam/2.0)*ks
Hctotal = C*(2.0/3.14159)*ks*rc_sakatani*xi
H = 1.0/((1.0/Hs) + (1.0/Hctotal))
k_sakatani = (2.0/3.14159)*(1.0-porosity)*H/(sphere_diam/2.0)


#Gundlach and Blum Solid conductivity, 2013
surfenergySiO = (6.67e-5)*T  #equation 11
#surfenergySiO = 0.020
f1 = 5.18e-2
f2 = 5.26
if(hasvalue(X)==0){
  X = 0.41 #tuneable parameter. Range from 0.31 to 0.51 for apollo samples. Preferred val 0.41  
}
if(verbosity==1){
printf("X: %f\n",X)
}
buffer = f1*exp(f2*(1.0-porosity))
#poissonsGB = 0.25  #values used for Itokawa (stony)
#youngsGB = 7.8e10
#ks = 2.18
#GB_s = (((9.0*3.14159/4.0)*((1.0-poissonsGB^2.0)/youngsGB)*(surfenergySiO/(sphere_diam/2.0)))^(1./3.))*buffer*X*ks
GB_s = (((9.0*3.14159/4.0)*((1.0-poissons^2.0)/youngs)*(surfenergySiO/(sphere_diam/2.0)))^(1./3.))*buffer*X*ks


###RADIATION

#Determining the non-isothermal correction factor, fk

#Dimensionless solid conductivity parameter
Lambda_s = ks/(4.0*sphere_diam*stefan_boltzmann*T^3)
if(verbosity==1){
  printf("Isothermal correction Lambda: %f\n",1.0/Lambda_s)
}
#if((1.0/Lambda_s)>=0.01 && (1.0/Lambda_s)<=10){
if(new_fk==0){
    a1 = 0.0841*emiss^2 - 0.307*emiss - 0.1737
    a2 = 0.6094*emiss + 0.1401
    a3 = 0.5738*emiss^(-0.2755)
    a4 = 0.0835*emiss^2 - 0.0368*emiss + 1.0017
  } else {
    a1 = -0.568
    a2 = 0.912
    a3 = 0.765
    a4 = 1.035
  }
  fk_predicted = a1*atan(a2*(1/Lambda_s)^a3) + a4
  fk_predicted[where fk_predicted>1.0] = 1.0
#} else {
#  fk_predicted = 1.0
#}

if(verbosity==1){
  printf("fk predicted: %f\n",fk_predicted)
}

if(wall==0){

  #Short range conductivity
  #surface area of the sphere
  As = 4.0*3.14159*(sphere_diam/2.0)^2.0

  #view factor between spheres
  F12 = 0.0756

  krS_vector = (4.0*sphere_diam*stefan_boltzmann*As*T^3)/((sphere_diam^2.0)*(((2-2*emiss)/emiss) + (1.0/F12)))

  if(cos==0){
    krS = (2.0*Nc*sphere_diam*stefan_boltzmann*As*T^3)/((sphere_diam^2.0)*(((2.0-2.0*emiss)/emiss) + (1.0/F12)))*sin(contact_angle*3.14159/180.)*fk
    krS_contact = (2.0*Nc*stefan_boltzmann*As*T^3)/((sphere_diam^2.0)*(((2.0-2.0*emiss)/emiss) + (1.0/F12)))*sin(contact_angle*3.14159/180.)*fk
  } else {
    krS = (2.0*Nc*sphere_diam*stefan_boltzmann*As*T^3)/((sphere_diam^2.0)*(((2.0-2.0*emiss)/emiss) + (1.0/F12)))*cos(contact_angle*3.14159/180.)*fk
    krS_contact = (2.0*Nc*stefan_boltzmann*As*T^3)/((sphere_diam^2.0)*(((2.0-2.0*emiss)/emiss) + (1.0/F12)))*cos(contact_angle*3.14159/180.)*fk
  }

  
  if(verbosity==1){
  printf("krS_vector = %f\n",krS_vector)
  printf("krS = %f\n",krS)
  }


  #Average long-range view factor, from Pitso, 2009
  FL12_avg = 0.0199
  nlong = 4.7  #long range radiative coordination number


  krL = (5.32*sphere_diam*stefan_boltzmann*As*(T^3)*nlong)/((sphere_diam^2.0)*(((2.0-2.0*emiss)/emiss) + (1.0/FL12_avg)))*fk
  krL_contact = (5.32*stefan_boltzmann*As*(T^3)*nlong)/((sphere_diam^2.0)*(((2.0-2.0*emiss)/emiss) + (1.0/FL12_avg)))*fk

  if(verbosity==1){
  printf("krL = %f\n",krL)
  }

  kr_tot = krS + krL

} else {
  emiss_aluminum = 0.07


  #Short range radiation

  #view factor
  FW12 = 0.315

  A1 = 4.0*3.14159*(sphere_diam/2.0)^2.0

  #Wall area participating in the radiative exchange
  A2 = 63.77*3.14159*(sphere_diam/2.0)^2.0

  krSW = (2.0*sphere_diam*stefan_boltzmann*T^3)/((sphere_diam^2.0)*(((1.0-emiss)/(emiss*A1)) + (1.0/(A1*FW12)) + ((1.0-emiss_aluminum)/(emiss_aluminum*A2))))

  #Long range radiation
  FLW12_avg = 0.02356
  A2 = 63.68*3.14159*(sphere_diam/2.0)^2.0
  nWlong = 1.0  #coordination number

  krLW = (4.536*sphere_diam*stefan_boltzmann*T^3)/((sphere_diam^2.0)*(((1.0-emiss)/(emiss*A1)) + (1.0/(A1*FLW12_avg)) + ((1.0-emiss_aluminum)/(emiss_aluminum*A2))))*fk

  if(verbosity==1){
  printf("Wall short radiation: %f\n",krSW)
  printf("Wall long radiation: %f\n",krLW)
  }

  kr_tot = krSW + krLW

  krS = krSW
  krL = krLW
}


k_tot = kr_tot + kgce

#return(k_tot)

zbs = zbs(T,P,sphere_diam,porosity,kr_tot,ks,rc,Nc)

if(verbosity==1){
printf("Total effective conductivity: %f\n",k_tot)
printf("Total radiative conductivity: %f\n",kr_tot)
printf("zbs = %f\n",zbs)
}



out = {}


if(hasvalue(zeta)==0){
  zeta = 1.0
}
if(hasvalue(e1)==0){
  e1 = 1.34
}
out.sakatanir = sakatani(emiss,sphere_diam,T,porosity,zeta)
out.GB_rad = gundlach(emiss,sphere_diam,T,porosity,e1)

out.kgce = kgce
out.kgce_vector = kgce_vector
out.kgce_contact = kgce_contact
#out.kgas = kgas
out.siu_keff = keff_siu
out.siu_keff180 = keff_siu180
out.R180 = R180
out.sakatani = k_sakatani
out.kr_tot = kr_tot
out.krS = krS
out.krS_contact = krS_contact
out.krL = krL
out.krL_contact = krL_contact
out.contact = krS_contact + krL_contact + kgce_contact
out.k_tot = k_tot
out.GB_solid = GB_s
#out.AG = AG
#out.BG = BG
out.Rj = Rj
out.rc = rc
out.Nc = Nc
out.contact_angle = contact_angle
out.C = C
out.rho = rho
out.fk_predicted = fk_predicted
out.zeta = zeta
out.xi = xi

out.Rin12 = Rin12
out.Rout12 = Rout12
out.Rmid12 = Rmid12
out.Rhertz12 = R_hertz12

out.kvort = vortmeyer(emiss,sphere_diam,T)
out.kbreit = breitbach(emiss,ks,sphere_diam,T,porosity)

out.robold = robold(emiss,ks,sphere_diam,T,porosity)
out.Rgas = RG
#out.j = j
#out.aTj = aTj
out.Rlambda = Rlambda
out.rlambda = rlambda
out.ksingh = singh(emiss,ks,sphere_diam,T,"diffuse")
out.argo = argo(emiss,sphere_diam,T)


out.schotte = schotte(emiss,ks,sphere_diam,T,porosity)
out.zbs = zbs
out.sample = sample
out.cos = cos
out.Rout_flag = Rout
out.Lambda_s = Lambda_s



return(out)

}


define porosity(){
  distance = $1
  sphere_diam = $2
  phi_mean = $3

  z = distance/sphere_diam


  if(dim(z)[2] >1 ){
    z = translate(z,from=y,to=x)
    translate="y"
  } else if(dim(z)[3]>1){
    z = translate(z,from=z,to=x)
    translate="z"
  } else {
    translate="x"
  }

  if(dim(phi_mean)[2] >1 ){
    phi_mean = translate(phi_mean,from=y,to=x)
    translate="y"
  } else if(dim(phi_mean)[3]>1){
    phi_mean = translate(phi_mean,from=z,to=x)
    translate="z"
  } else {
    translate="x"
  }


  phi = z*0.0
  for(i=1 ; i<=dim(z)[1] ; i++){
    if(z[i,,]<=0.5){
      #phi[i,,] = 2.14*z[i,,]^2 - 2.53*z[i,,] + 1.0
      #phi[i,,] = 0.246275 #Value at 1/2 sphere diameter from wall. 
      phi[i,,] = -0.0127*0.5^2 + 0.0967*0.5 + phi_mean + (0.2011-0.385) #Value of function at 0.5 distance. 
    } else if(z[i,,]<=3.8){
      phi[i,,] = -0.0127*z[i,,]^2 + 0.0967*z[i,,] + phi_mean + (0.2011-0.385) #Adjusted so curve offsets to match phi_mean
    } else {
      if(dim(phi_mean)[1]>1){
        phi[i,,] = phi_mean[i,,]
      } else {
        phi[i,,] = phi_mean
      }

    }
  }

  if(dim(phi_mean)[1] >1 && dim(z)[1]==1){
    phi = phi_mean*0.0
    for(i=1 ; i<=dim(phi_mean)[1] ; i++){
    if(z<=0.5){
      phi[i,,] = 2.14*z^2 - 2.53*z + 1.0
    } else if(z<=3.8){
      phi[i,,] = -0.0127*z[i,,]^2 + 0.0967*z[i,,] + 0.2011
    } else {
      phi[i,,] = phi_mean[i,,] 
    }
  }

  }
  
  phi = translate(phi,from=x,to=sprintf(translate))
  return(phi)

}



define Nc(wall){

porosity = $1

if(hasvalue(wall)==0){
  wall=0
}

#if(wall==1){
#  #van Antwerpen 2010
#  Nc = 25.952*porosity^3 - 62.364*porosity^2 + 39.724*porosity - 2.0233
#} else {
#  #coordination number, Suzuki et al 1981
#  f = 0.07318 + 2.193*porosity - 3.357*porosity^2 + 3.194*porosity^3
#  Nc_suzuki = (2.812*(1.0-porosity)^(-1./3.))/((f^2)*(1.0 + f^2)) 
#}

Nc = 25.952*porosity^3 - 62.364*porosity^2 + 39.724*porosity - 2.0233

return(Nc)

}


define Nc_2() {

if($ARGC==0){
  printf("Coordination number.\n")
  printf("$1 = phi\n")
  return(0)
}

phi = $1
#from Yang et al. 2000
coord = 2.02*(1 + 87.38*(1.-phi)^4.)/(1. + 25.81*(1.-phi)^4.)

return(coord)
}


define Nc_suzuki(){
  porosity=$1
  f = 0.07318 + 2.193*porosity - 3.357*porosity^2 + 3.194*porosity^3
  C = (2.812*(1.0-porosity)^(-1./3.))/((f^2.)*(1.0 + f^2.)) #coordination number, Suzuki et al 1981
  return(C)
}

define contact_angle(){

Nc = $1
if(Nc<5.333){
  Nc = 5.33
}
phi_c = -6.1248*Nc^2 + 73.419*Nc - 186.68
return(phi_c)

}


define Fmech(){
if($ARGC==0){
  printf("Calculates mechanical load on particals at depth\n")
  printf("For now, assumes constant density\n")
  printf("$1 = depth (m)\n")
  printf("$2 = bulk density, kg/m3\n")
  printf("$3 = particle radius, Rs, m\n")
  printf("$4 = coordination number, Nc\n")
  printf("$5 = phi\n")
  printf("$6 = planet, supports mars, earth, moon, bennu, itokawa\n")
  return(null)
}


depth = $1
rho = $2
#Rc = $3
Rs = $3
Nc = $4
phi = $5
planet = $6

if(planet=="earth" || planet=="Earth"){
  g = 9.80665
} else if(planet == "mars" || planet == "Mars"){
  g = 3.711
} else if(planet == "moon" || planet == "Moon"){
  g = 1.622
} else if(planet == "Itokawa" || planet == "itokawa"){
  g = 0.086e-3
} else if(planet == "Bennu" || planet == "bennu"){
  g = 75.0e-6
} else if(planet == "Eros" || planet== "eros"){
  g = 0.003 #Calculated assuming mean mass and diameter  
} else if(planet == "Ryugu" || planet== "ryugu"){
  g = 1.6e-4  #Calculated assuming mean mass and diameter
} else {
  printf("Planet not supported! Assuming Earth.\n")
  g = 9.80665
}

pi = 3.14159265359

Fmech = 4.*pi*(Rs^2.)*rho*g*depth/(Nc*(1.-phi)) 

#Fmech = 2.0*rho*g*depth*4.0*pi*(Rs^2.0)/Nc

#Sakatani
#Can also remove last 1.0-phi
#Fmech = (2.0*pi*(Rs^2.0)/(sqrt(6.0)*(1.0-phi)))*rho*(1.0-phi)*g*depth
return(Fmech)

}

define Fmech2(){
  depth = $1
  rho = $2
  Rs = $3
  phi = $4
  planet = $5

if(planet=="earth" || planet=="Earth"){
  g = 9.80665
} else if(planet == "mars" || planet == "Mars"){
  g = 3.711
} else if(planet == "moon" || planet == "Moon"){
  g = 1.622
} else if(planet == "Itokawa" || planet == "itokawa"){
  g = 0.086e-3
} else if(planet == "Bennu" || planet == "bennu"){
  g = 75.0e-6
} else if(planet == "Eros" || planet== "eros"){
  g = 0.003 #Calculated assuming mean mass and diameter  
} else if(planet == "Ryugu" || planet== "ryugu"){
  g = 1.6e-4  #Calculated assuming mean mass and diameter
} else {
  printf("Planet not supported! Assuming Earth.\n")
  g = 9.80665
}


  pi = 3.14159
  F = 2.0*pi*rho*g*depth*(Rs^2.0)/(sqrt(6.0)*(1.0-phi))

  return(F)
}


define rc_jkr(old) {
if($ARGC==0){
printf("Relative contact radius, equation 21\n")
printf("rcon = Rcon/Rs\n")
printf("$1 = Rloc, or Rs, radius in m if spherical\n")
printf("$2 = Force of overlying mechanical load, in N\n")
printf("$3 = Surface energy, J/m^2, Gamma. Try 0 \n")
printf("$4 = Poissons ratio, v\n")
printf("$5 = Young's Modulus, Pa\n")
return(null)
}

if(hasvalue(old)==0){
  old = 0
}

Rloc = float($1)
Fmech = float($2)
Gamma = float($3)
v = float($4)
E = float($5)

Rstar = Rloc/2.

pi = 3.141592653

F_con_jkr = (Fmech + 3*pi*Gamma*Rstar + sqrt(6.*pi*Gamma*Rstar*Fmech + (3.*pi*Gamma*Rstar)^2))
if(old==1){
  #Alternate form of equation was used in error before. 
  F_con_jkr = (Fmech + 6*pi*Gamma*Rstar + sqrt(12.*pi*Gamma*Rstar*Fmech + (6.*pi*Gamma*Rstar)^2))
}
R_con_jkr = (3.*Rstar*(1-v^2)*F_con_jkr/(2.*E))^(1./3.)

return(R_con_jkr)

}


define rc_jkr2(old) {
if($ARGC==0){
printf("Relative contact radius, equation 21\n")
printf("rcon = Rcon/Rs\n")
printf("$1 = Rloc, or Rs, radius in m if spherical\n")
printf("$2 = Force of overlying mechanical load, in N\n")
printf("$3 = Surface energy, J/m^2, Gamma. Try 0 \n")
printf("$4 = Poissons ratio, v\n")
printf("$5 = Young's Modulus, Pa\n")
return(null)
}

if(hasvalue(old)==0){
  old = 0
}

R1 = float($1)
R2 = float($2)
Fmech = float($3)
Gamma = float($4)
v = float($5)
E = float($6)

Rstar = R1*R2/(R1 + R2)

pi = 3.141592653

F_con_jkr = (Fmech + 3*pi*Gamma*Rstar + sqrt(6.*pi*Gamma*Rstar*Fmech + (3.*pi*Gamma*Rstar)^2))
if(old==1){
  #Alternate form of equation was used in error before. 
  F_con_jkr = (Fmech + 6*pi*Gamma*Rstar + sqrt(12.*pi*Gamma*Rstar*Fmech + (6.*pi*Gamma*Rstar)^2))
}
R_con_jkr = (3.*Rstar*(1-v^2)*F_con_jkr/(2.*E))^(1./3.)

return(R_con_jkr)

}


define rc(){
  depth = $1
  sphere_diam = $2
  youngs_modulus = $3

  #NEED TO UPDATE THIS
  F = 72.308*depth + 7.8716
  rc = (((0.75*F*(sphere_diam/2))/youngs_modulus))^(1.0/3.0)
  return(rc)

}


define R_hertz12(){
  ks = $1
  rc = $2
 
  out = 0.64/(ks*rc)
  return(out)

}



define omega_nought(){
  rc = $1
  sphere_diam = $2
  
  out = (rc^2)/sphere_diam
  return(out)
}


define Rin12(){
  sphere_diam=$1
  rc = $2
  omega = $3
  ks = $4
  
  out = (sphere_diam - omega)/(ks*3.14159*(rc^2))
  return(out)
}


define mfp(gas,T,P) {

if($ARGC == 0) {
    printf (" Returns a scalar \n")
    printf (" Calculates the mean free path in m of various gas molecules \n")
    printf (" $1 = a string indicating the nature of the gas, between double quotes \n")
    printf (" Supported gases are CO2, N2, O2, CH4, He, H2, SO2, and H2O \n")
    printf (" $2 = Temperature in K \n")
    printf (" $3 = Pressure in Pa \n")
    printf (" The output is the mean free path in m \n")
               }

if($ARGC !=0){

gas = $1
T = float($2)
P = float($3)

#Loads the constants associated with each gas
if (gas == "CO2") {
  diam =  4.6
   } else {
if (gas == "N2") {
  diam = 4.048
  #diam = 3.6
   } else {
if (gas == "O2") {
  diam = 3.906
    } else {
if (gas == "CH4") {
  diam =  4.286
    } else {
if (gas == "He") {
  diam =  2.651
    } else {
if (gas == "H2") {
  diam =  3.260
    } else {
if (gas == "SO2") {
  diam =  4.604
    } else {
if (gas == "H2O") {
  diam = 3.042
                   }}}}}}}}

#Mean free path calculation
mfp = 1.3806488E-23*T/(P*3.14159265*(diam*1.E-10)^2*sqrt(2.))

return(mfp)

}
}


define rlambda(){
  sphere_diam = $1
  omega0 = $2
  mfp = $3
  val = (sphere_diam/2)^2 - ((sphere_diam/2) - 0.5*omega0 - 5*mfp)^2
  if(val>0){
    rlambda = sqrt(val)
  } else {
    rlambda = sphere_diam/2.0
  }
  return(rlambda)

}


define k0(gas,T) {

if($ARGC == 0){
    printf (" Returns a scalar \n")
    printf (" Calculates a gas thermal conductivity in the continuum (high P) domain \n")
    printf (" $1 = the gas composition, between double quotes \n")
    printf (" Supported gases are CO2, N2, O2, CH4, He, H2, SO2, and H2O \n")
    printf (" $2 = Temperature in K \n")
              }

if($ARGC !=0){

gas = $1
T = $2

#Constants given by DIPPR 801

if (gas == "CO2") {
  a = 3.69
  b = -0.3838
  c = 964.0
  d = 1860000
    } else {
if (gas == "N2") {
  a = 0.00033143
  b = 0.7722
  c = 16.323
  d = 373.72
    } else {
if (gas == "O2") {
  a = 0.00044994
  b = 0.7456
  c = 56.699
  d = 0.0
    } else {
if (gas == "CH4") {
  a = 0.0000083983
  b = 1.4268
  c = -49.654
  d = 0.0
    } else {
if (gas == "He") {
  a = 0.00226
  b = 0.7305
  c = -18.63
  d = 440.0
    } else {
if (gas == "H2") {
  a = 0.002653
  b = 0.7452
  c = 12.0
  d = 0.0
    } else {
if (gas == "SO2") {
  a = 0.00035686
  b = 0.73812
  c = 795.65
  d = 0.0
    } else {
if (gas == "H2O") {
  a = 0.0000062041
  b = 1.3973
  c = 0.0
  d = 0.0
}}}}}}}}

k0_1 = (a*T^b)/(1+c/T+d/T^2)

return(k0_1)

}
}




define vortmeyer(){
#Kasparek and Vortmeyer 1976
e = $1
diam = $2
T = $3

sigma = 5.670367e-8

eprime = e/(e + 0.5*(1.0-e))
B = 0.08


omega = (2.0*B + eprime*(1.0-B))/(2.0*(1.0-B) - eprime*(1.0-B))
krad = 4.0*omega*diam*sigma*T^3
return(krad)

}


define robold(){
#Robold 1982

e = $1
ks = $2
diam=$3
T= $4
phi=$5

sigma = 5.670367e-8
pi = 3.14159

Br = 0.0894306 -  0.14456*e + 0.106337*e^2 + 0.0159144*e^3 - 0.0325521*e^4
FE = (2.0*Br + e*(1.0 - Br))/((1.0-Br)*(2.0-e))
FE0 = e/(2.0-e)
X = FE0/FE
Br0 = 0.0875
delta0 = (FE*(1.0-Br0) - Br0)/(FE0*(1.0-Br0))

de = (0.523/(1.0-phi))*diam
des = de*pi/(1.0+pi)

FEs = FE*(1.0 - X*(delta0/(1.0+(ks/(FE0*4*des*sigma*T^3)))))
krad = 4.0*FEs*diam*sigma*T^3

return(krad)
}

define breitbach(){
#Breitbach and Barthels 1980
e = $1
ks = $2
diam=$3
T = $4
phi = $5

sigma = 5.670367e-8
B = 1.25*((1.0-phi)/phi)^(10.0/9.0)

Lambdaf = ks/(4.0*diam*sigma*T^3.0)

FE = ((1.0-sqrt(1.0-phi))*phi + (sqrt(1.0-phi)/((2.0/e) - 1.0))*((B+1.0)/B)*(1.0/(1.0+(1.0/(((2.0/e)-1.0)*Lambdaf)))))
krad = 4.0*FE*diam*sigma*T^3
return(krad)
}


define singh(){
#Singh and Kaviany, 1994
e = $1
ks = $2
diam=$3
T=$4
type=$5

if(type=="specular"){
  a1 = 0.5711
  a2 = 1.4704
  a3 = 0.8237
  a4 = 0.2079
} else if(type=="diffuse"){
  a1 = 0.5756
  a2 = 1.5353
  a3 = 0.8011
  a4 = 0.1843
} else {
  printf("Invalid type. $5 must be specular or diffuse\n")
  return(0)
}
sigma = 5.670367e-8
Lambdaf = ks/(4.0*diam*sigma*T^3.0)

FE = a1*e*atan(a2*((Lambdaf^a3)/e)) + a4
krad = 4.0*FE*diam*sigma*T^3
return(krad)

}



define argo(){
  e = $1
  diam = $2
  T = $3

  sigma = 5.670367e-8

  FE = 1.0/((2.0/e) - 1.0)

  krad = 4.0*FE*diam*sigma*T^3.0
  return(krad)

}

define sakatani(){
e = $1
diam = $2
T = $3
phi = $4
zeta = $5

pi = 3.14159
sigma = 5.670367e-8

#Values for zeta from Sakatani et al., 2017
#710-1000 um: 0.7-1.0
#355-500 um: 1.1-1.9
#180-250 um: 1.2-1.7
#90-106 um: 1.8-2.6
#53-63 um: 2.5-4.0
#emb powder 5 um: ~15

krad = 8.0*(e/(2.0-e))*sigma*zeta*((phi/(1.0-phi))^(1.0/3.0))*(diam/2.0)*T^3
return(krad)
}


define gundlach(){
#Gundlach and blum, 2012
e = $1
diam = $2
T = $3
phi = $4
e1 = $5

#e1 = 1.34
sigma = 5.670367e-8
k = 8.0*sigma*e*(T^3.)*e1*(phi/(1.0-phi))*(diam/2.0)
return(k)


}


define schotte(){
#Schotte 1960, taken from Huetter 2008
e = $1
ks = $2
diam = $3
T = $4
phi = $5

sigma = 5.670367e-8


buffer = 4.0*diam*sigma*e*phi*T^3
k = (1.0-phi)/((1/ks) + 1.0/(buffer)) + buffer
return(k)
}


#################################
define Kn(gas,T,P,grain_diam,phi){

if($ARGC == 0){
    printf (" Returns a scalar \n")
    printf (" Calculates the Knudsen number in the pores of soils \n")
    printf (" $1 = the gas composition, between double quotes \n")
    printf (" Supported gases are CO2, N2, O2, CH4, He, H2, SO2, and H2O \n")
    printf (" $2 = Temperature in K \n")
    printf (" $3 = Pressure in Pa \n")
    printf (" $4 = the grain diameter in m \n")
    printf (" $5 = the porosity, <1 \n")
    printf (" The pore size is calculated from pore() => spherical pores \n")
              }

if($ARGC !=0){

mfp = mfp($1,float($2),float($3))
pore = pore($4,$5)
Knudsen = mfp/pore

return (Knudsen)

}
}




#########################
define pore(diam,phi) {

if($ARGC == 0){
    printf (" Returns a scalar \n")
    printf (" Calculates the typical pore size in homogeneous samples \n")
    printf (" $1 = the grain diameter in m \n")
    printf (" $2 = the porosity, <1 \n")
    printf (" MANY MORE PORE SIZE FUNCTIONS EXIST AND SHOULD BE INCLUDED \n")
              }

if($ARGC !=0){

diam = $1
phi=$2

#Assumes that the pores are homogeneous spheres
#Add more pore size formulas here and references
#Grain size mixtures ?
pore = 0.5*diam*(phi/(1-phi))^0.333


return (pore)

}
}








define kgas0(){
#From Jensen et al 1980

T = $1


k = ((2.57e-3)*sqrt(T))/(1.0+(235.5/T)*10^(-12.0/T))

return(k)
}




###############
define k_gas(){

if($ARGC==0){
        printf("Calculates the normalized gas conductivity from Kn\n")
        printf("$1 = gas composition (CO2, N2, O2, CH4, H2, H2, SO2, or H2O)\n")
        printf("$2 = Temperature in K\n")
        printf("$3 = Pressure in Pa\n")
        printf("$4 = grain diameter in m\n")
        printf("$5 = the porosity, <1\n")
        printf("The pore size is calculated from pore(), assumes spherical pores\n")
        return(null)
}


Kn = Kn($1,$2,$3,$4,$5)
printf("Knudsen number: %f\n",Kn)
buffer = -(log10(1./Kn)-2.15)/0.55
buffer_2 = 1./(1.+exp(buffer))
printf("buffer2: %f\n",buffer_2)

k0 = kgas0($2)

k_gas = k0*buffer_2
printf("k_gas: %f\n",k_gas)
return(k_gas)
}


define zbs(){
  if($ARGC==0){
    printf("ZBS model for conduction in packed bed of spheres with stagnant gas\n")
    printf("$1 = T\n")
    printf("$2 = P\n")
    printf("$3 = sphere_diam\n")
    printf("$4 = porosity\n")
    printf("$5 = kr\n")
    printf("$6 = ks\n")
    printf("$7 = rc\n")
    return(null)

  }
  T = $1
  P = $2
  sphere_diam = $3
  porosity = $4
  kr = $5
  ks = $6
  rc = $7
  Nc = $8


  R = 8.314 #J/mol/K   Universal Gas constant
  pi = 3.14159
  C = 1.25
  m = (10.0/9.0)

  Cp = 1039.0 #J/kg/K specific heat of nitrogen at constant pressure <~300 K

  kf = kgas0(T)
  M_gas = 28.013 #g/mol
  Mstar = M_gas*1.4 #if gas is dia/polyatomic. Otherwise, Mstar = M_gas
  Pr = 0.69 #N2 prandlt number
  cpcv = 1.40 #ratio of specific heat for nitrogen
  M_glass = 526.45 #pyrex molecular mass
  um = M_gas/M_glass
  T0 = 273.15
  aTj = exp(-0.57*((T - T0)/T0))*(Mstar/(6.8 + Mstar)) + ((2.4*um)/((1+um)^2))*(1.0 - exp(-0.57*((T - T0)/T0)))

  l = 2.0*((2.0-aTj)/aTj)*(sqrt((2.0*pi*R*T)/M_gas))*(kf/(P*(2.0*Cp - (R/M_gas))))
  KG = (1.0+(l/sphere_diam))^(-1.0)

  B = C*(((1.0-porosity)/porosity)^m)

  Kr = kr/kf  #radiative conduction ratio
  K = ks/kf  #solid conduction ratio

  N = (1.0/KG)*(1.0 + ((Kr - B*KG)/K)) - B*((1.0/KG) - 1.0)*(1.0 + (Kr/K))
  #N = Nc

  #phi = (Nc/4.0)*((rc/sphere_diam)^2.0)

  #phi = 1.0 - (sphere_diam/2.0)

  phi = rc

  kc = (2.0/N)*((B*(K + Kr - 1.0)/((N^2.0)*KG*K))*ln((K + Kr)/(B*(KG + (1.0-KG)*(K + Kr)))) + ((B+1.0)/(2.0*B))*((Kr/KG) - B*(1.0 + Kr*((1.0-KG)/KG))) - ((B - 1.0)/N*KG))

  keff = (1.0-sqrt(1.0-porosity))*porosity*(((porosity - 1.0 + 1.0/KG)^(-1.0)) + Kr) + sqrt(1.0-porosity)*(phi*K + (1.0-phi)*kc)*kf

  
  return(keff)
} #end zbs


define zbs_rad(){
  if($ARGC==0){
    printf("$1 = phi\n$2 = emissivity\n$3 = T\n$4 = ks\n$5 = diam\n\n")
    return(null)
  }
  phi = $1
  emiss = $2
  T = $3
  ks = $4
  diam = $5

  sigma = 5.670367e-8

  #formuation found in Wu et al. 2016 and in Van antwerpen dissertation appendix
  Lambda = ks/(4.0*diam*sigma*T^3.0)

  B = 1.25*(((1.0-phi)/phi)^(10.0/9.0))

  buffera = sqrt(1.0-phi)/((2.0/emiss) - 1.0)
  bufferb = (B + 1.0)/B
  bufferc = ((2.0/emiss) - 1.0)*Lambda
  bufferd = 1.0/(1.0 + (1.0/bufferc))

  F = (1.0 - sqrt(1.0-phi))*phi + buffera*bufferb*bufferd

  kr = 4.0*sigma*diam*F*T^3.0

  return(kr)


}



define ks_glass(){
#glass solid conductivity
T = $1

#Curve 94, Type C from Touloukian et al., 1971. 
#This curve was used for Ryan dissertation
#ks = ((-3.277E-08)*T^2 + (3.471E-05)*T + 3.308E-03)*100.0 

#Modeled Value - van der Tempel, 2002
#I also added an offset term so that the curve intersects the room tempeature TC value provided by Jaygo. 
#Cp from Siegler et al., 2012
#Cp = (0.0000128)*T^3 - (0.0119)*T^2 + 5.14*T -110.4
#ks = (1.68*(Cp/2495)^0.38) + 0.095

#Siegler 2012 fit from sciglass database
#ks = (1.5e-3)*(T-273.15) + 1.1277

#Fit to modeled glass curve based on Ratcliff, 1963 model. S-Type Jaygo. 
ks = 0.3319 + (4.216e-3)*T - (5.1e-6)*T^2

return(ks)
}

define ks_glass10(){
  #glass solid conductivity
  T = $1

  #Fit to modeled glass curve based on Ratcliff, 1963 model. M-Type Jaygo (1 cm diameter)
  ks = 0.2296 + (4.7e-3)*T - (6.05e-6)*T^2
  
  return(ks)
}

define ks_glass5(){
  #glass solid conductivity
  T = $1

  #Fit to modeled glass curve based on Ratcliff, 1963 model. M-Type Jaygo (5 mm diameter)
  ks = 0.2852 + (3.175e-3)*T - (2.7e-6)*T^2
  
  return(ks)
}




define ks_basalt(){
  #Basalt solid conductivity from Desai et al., 1974; Sakatani et al., 2016;2018
  T = $1
  ks = (-9.53e-4)*T + 2.4 
  return(ks)
}

define ks_tagish(){
  #Tagish lake sim conductivity estimated from Cold Bokkeveld (CM2), Opeil et al 2010
  T = $1
  #ks = -0.0254 + 0.00563*T - (2.07e-5)*T^2 + (3.11e-8)*T^3 #Doesn't extrapolate well...
  ks = 0.26 + 0.0013*T #simple fit, valid from 100-300 K

  #ks = 1.26 + 0.0011*T  #Alernative value using NWA 5515 (CK4)

  #ks = 0.76 + 0.0012*T #Average of Cold Bokkeveld and NWA conductivity
  return(ks)
}

define ks_CK(){
  T = $1

  ks = 1.26 + 0.0011*T  #Alernative value using NWA 5515 (CK4)

  return(ks)

}

define ks_ottawa(){
  T = $1
  ks = (3880.8)*(T^-1.0667)
  return(ks)
}



define ks_glass_sakatani(){
#glass solid conductivity, from Sakatani et al., 2017
T = $1

ks = (8.50e-4)*T + 0.855
return(ks)

}


define ks_graphite(){
  #From van Antwerpen et al 2012 figure 24 and 25
  #input is celcius
  T = $1 -273.15
  ks = 186.021 - (39.5408e-2)*T + (4.8852e-4)*T^2.0 - (2.91e-7)*T^3.0 + (6.6e-11)*T^4.0

  return(ks)
}


define emiss_HTO(){
  T = $1
  emiss = 0.505586 + 0.000792943*T - (5.22863e-7)*T^2 + (1.10479e-10)*T^3
  return(emiss)
}

define ks_HTO(){
  T = $1
  ks = 73.8428 - 0.0898607*T + (5.57553e-5)*T^2 - (1.27420e-8)*T^3
  return(ks)
}

define ryan(){

sphere_diam = $1
T = $2

M = 0.135 - (1.09e-3)*T - (1.80e-6)*T^2 + (3.30e-8)*T^3

N = 0.105 + (3.49e-3)*T - (7.69e-6)*T^2 + (6.04e-9)*T^3

k = M*sphere_diam^N

return(k)


}


define generate_plots(){
 if($ARGC==0){
   printf("$1 = name\n$2 = rc\n$3 = fk\n")
   return(null)
 }

name = $1
rc = $2
fk = $3

if(dim(rc)[2]<=1){
  printf("rc and fk 7-dimension must be greater than 1!\n")
  return(null)
}
if(dim(rc)[2] != dim(fk)[2]){
  printf("rc and fk dimensions must be the same!\n")
  return(null)
}

length = dim(rc)[2]

T = translate(create2(80.,5.0,430.0),from=y,to=x)
Tarray = clone(0.0,71,length,1)
Tarray[,1:length,] = T

if(name=="100um"){
  diam = 96.0e-6
  phi = 0.42
  depth = 0.01
  solid_rho = 2495.0
  sample_type="glass"
} else if(name=="basalt_fine"){
  diam = 4.76e-3
  phi = 0.465
  depth = 0.03
  solid_rho = 2964.0
  sample_type="basalt"
} else if(name=="basalt_med_fine"){
  diam = 7.94e-3
  phi = 0.48
  depth = 0.03
  solid_rho = 2964.0
  sample_type="basalt"
} else if(name=="basalt_med_coarse"){
  diam = 1.11e-2
  phi = 0.538
  depth = 0.03
  solid_rho = 2964.0
  sample_type="basalt"
} else if(name=="basalt_coarse"){
  diam = 1.43e-2
  phi = 0.554
  depth = 0.03
  solid_rho = 2964.0
  sample_type="basalt"
} else if(name=="tagish_fine"){
  diam = 4.76E-03
  phi = 0.475
  depth = 0.03
  solid_rho = 1900.0
  sample_type = "tagish"
} else if(name=="tagish_fine_2"){
  diam = 4.76E-03
  phi = 0.440
  depth = 0.03
  solid_rho = 1900.0
  sample_type = "tagish"
} else if(name=="tagish_med_fine"){
  diam = 7.94E-03
  phi = 0.420
  depth = 0.03
  solid_rho = 1900.0
  sample_type = "tagish"
} else if(name=="tagish_med_coarse"){
  diam = 1.11E-02
  phi = 0.430
  depth = 0.03
  solid_rho = 1900.0
  sample_type = "tagish"
} else if(name=="tagish_coarse"){
  diam = 1.43E-02
  phi = 0.420
  depth = 0.03
  solid_rho = 1900.0
  sample_type = "tagish"
} else {
  printf("Unknown sample name!\n")
  return(null)
}

out = keff(diam,depth,1.0,phi,Tarray,1.0e-10,1.0,solid_rho*(1.0-phi),"N2",rc_factor=rc,surfenergy=0.02,fk=fk,sample=sample_type)

out.T = T
out.Tarray = Tarray
pplot(translate(out.kr_tot+out.kgce,from=x,to=z),xaxis=out.T,xlabel="Temperature [K]",ylabel="Thermal Conductivity [W/m K]")
return(out)

}



define integrate_cylinder(){
  radius = double($1)
  height = double($2)
  sphere_diam = double($3)
  phi_bulk = double($4)
  div = double($5)
  pi = double(3.14159265)
  density = double(2500.0)
  
  delta = sphere_diam/div
  deltaR = radius/round(radius/delta)
  deltaZ = height/round(height/delta)
  sum = double(0.0)
  sum2 = double(0.0)
  tot_vol = pi*height*radius^2
  vol_sum = double(0.0)

  central = 0

#if((radius>sphere_diam*5.0) && (height>sphere_diam*10.0)){
    #We can calculate the inner integral analytically because phi is not changing. 
#    inner_volume = pi*(height - (sphere_diam*10.0))*(radius - sphere_diam*5.0)^2
#    printf("Calc middle region\n")
#    printf("Inner vol: %f\n",inner_volume)
#    vol_sum += inner_volume
#    inner_mass = (1.0-phi_bulk)*density*inner_volume
#    sum += inner_mass
#    start_r = radius - sphere_diam*5.0
#    central = 1
#
#  } else {
#    start_r = double(0.0)
#  }

  start_r = double(0.0)

  jump=0
  for(z = double(0.0) ; z<height-deltaZ/2 ; z+=deltaZ){
      if((central==1 && z>=sphere_diam*5.0) && jump==0){
        printf("doing jump at z = %f\n",z)
        z = height - sphere_diam*5.0
        printf("New z: %f\n",z)
        jump=1
        
      }
    for(r = start_r ; r< radius-deltaR/2 ; r+=deltaR){
      z_mid = z+deltaR/(double(2.0))
      r_mid = r+deltaZ/(double(2.0))
      sphere_dist = min(z_mid/sphere_diam//(radius-r_mid)/sphere_diam//(height-z_mid)/sphere_diam)
      #sphere_dist = min(z_mid/sphere_diam//(radius-r_mid)/sphere_diam)
      local_phi = deklerk(phi_bulk, sphere_dist)
      local_phi2 = white_and_tien(phi_bulk,sphere_dist)
      #local_phi = phi_bulk
      volume = (deltaZ*pi*((r+deltaR)^(double(2.)) - r^(double(2.))))
      vol_sum += volume
      mass = density*(double(1.0)-local_phi)*volume
      mass2 = density*(double(1.0)-local_phi2)*volume
      #printf("Value: %f\n",value*volume)
      sum += (mass)
      sum2 += mass2
    }
  }

  printf("vol_sum: %f\nexpected_vol: %f\n",vol_sum,tot_vol)
  tot_density = sum/vol_sum
  apparent_phi = 1.0 - tot_density/density
  tot_density2 = sum2/vol_sum
  apparent_phi2 = 1.0 - tot_density2/density
  printf("De Klerk: %f\nWhite and Tien: %f\n",apparent_phi,apparent_phi2)
#  return(apparent_phi)
}



define chantien(){
  packing = int($1)
  r = $2
  gamma = $3

  rc = r*gamma

  ks = 1.0

  Sj = 1.0//0.25//(1.0/3.0)
  SF = 1.0//sqrt(3.0/4.0)//1.0/(sqrt(6.0))

  #from table. approx for now. 
  SR = 1.0

  R = 0.531/(ks*rc)

  Rnoncubic = SR*0.64/(ks*rc)

  if(packing==1){
    NL = 1.0/(2.0*r)
    NA = 1.0/(4.0*r^2.0)
  } else if(packing==2){
    NL = sqrt(3.0)/(2.0*r)
    NA = 3.0/(16.0*r^2)
  } else if(packing==3){
    NL = sqrt(3.0)/(2.0*sqrt(2.0)*r)
    NA = 1.0/(2.0*sqrt(2.0)*r^2.0)
  } else {
    NA = 0.0
    NL = 1.0
  }

  k_simple = (NA/NL)*(1.0/(R*Sj[packing]))
  printf("k using 0.531: %f\n",k_simple)

  k = (NA/NL)*(1.0/(Rnoncubic*Sj[packing]*SR))
  printf("k with non-cubic approx: %f\n",k)

  Sp = (1.56/(SR*Sj[packing]))*(NA/NL)*((SF[packing]/NA)^(1.0/3.0))

  ke = Sp*ks

  printf("k using Sp: %f\n",ke)

  Nc = 6.0//8.0//12.0
  #Nc = 6.2

  Rk = (0.57588/(ks*rc))*(1.0 - ((1.0920e-3)/gamma) + ((3.0187e-5)/(gamma^2.0)) - ((1.202e-7)/(gamma^3.0)))
  Rc = (1.75e-15)/((rc*ks)^3.0)
  omega0 = (0.0125*Nc[packing]^2.0 + 0.0716*Nc[packing])*ks*gamma

  omega = omega0*Rk/(Rc + Rk)

  printf("Siu k: %f\n",omega0)
  printf("Siu k with contact resistance: %f\n",omega)



}


define krsc(alpha){
  
  #analytical expression for radiative conductivity of Simple cubic structure
  #From Wu et al. 2018
  #Does not take long-range radiation into account

  T = $1
  emiss = $2
  diam = $3


  pi = 3.14159
  sigma = 5.670367e-8

  #porosity
  if(hasvalue(alpha)==0){
    alpha = 1.0 - (pi/6.0)
  } 


  gamma = 1.0308

  buffer1 = pi*gamma/((2.0*(1.0-emiss)/emiss) + 6.0)
  buffer2 = ((6.0/pi)*(1.0 - alpha))^(1.0/3.0)

  F = buffer1*buffer2

  kr = 4.0*sigma*diam*F*T^3.0

  return(kr)
}


define krfcc(alpha){
  
  #analytical expression for radiative conductivity of Simple cubic structure
  #From Wu et al. 2018
  #Does not take long-range radiation into account

  T = $1
  emiss = $2
  diam = $3


  pi = 3.14159
  sigma = 5.670367e-8

  #porosity
  if(hasvalue(alpha)==0){
    alpha = 1.0 - (pi/(2.0*sqrt(2.0)))
  }

  gamma = 0.9183

  buffer1 = 2.0*sqrt(2.0)*pi*gamma/((2.0*(1.0-emiss)/emiss) + 12.0)
  buffer2 = ((6.0/(sqrt(2.0)*pi))*(1.0 - alpha))^(1.0/3.0)

  F = buffer1*buffer2

  kr = 4.0*sigma*diam*F*T^3.0
  return(kr)
}


define krbcc(alpha){
  
  #analytical expression for radiative conductivity of Simple cubic structure
  #From Wu et al. 2018
  #Does not take long-range radiation into account

  T = $1
  emiss = $2
  diam = $3


  pi = 3.14159
  sigma = 5.670367e-8

  #porosity
  if(hasvalue(alpha)==0){
    alpha = 1.0 - (pi/(2.0*sqrt(2.0)))
  }
  gamma = 0.9130

  buffer1 = 4.0*pi*gamma/(((2.0*(1.0-emiss)/emiss) + 10.1606)*sqrt(3.0))
  buffer2 = ((8.0/(sqrt(3.0)*pi))*(1.0 - alpha))^(1.0/3.0)

  buffer3 = 4.0*sqrt(3.0)*pi*gamma/((2.0*(1.0-emiss)/emiss) + 28.21595)
  buffer4 = ((8.0/(sqrt(3.0)*pi))*(1.0 - alpha))^(1.0/3.0)

  Fhex = buffer1*buffer2
  Fsqu = buffer3*buffer4

  Fcombined = (12.0*sqrt(3.0)*Fhex + 6.0*Fsqu)/(12.0*sqrt(3.0)+6.0)

  kr = 4.0*sigma*diam*Fcombined*T^3.0

  return(kr)

}


define generate_powerlaw(){
  #Note, this code is wrong. See fixed version below. 
  if($ARGC==0){
    printf("$1 = slope\n$2 = min\n$3=max\n$4=discretization\n\n")
    return(null)
  }
  slope = float($1)
  min = float($2)
  max = float($3)
  discretization = float($4)

  radii = create2(min,discretization,max+discretization)

  if(max(radii)<max){
    radii = cat(radii,max,axis=y)
  }

  dim = dim(radii)[2]

  diams = radii*2.0

  cumulAbund = radii^slope

  maxval = cumulAbund[,dim,]

  abund = cumulAbund - maxval

  sum = sum(abund)

  relAbund = abund/sum

  printf("%f %i\n",sum(double(relAbund)),dim)


  for(i = 1 ; i<=dim; i++){
    printf("%f ",radii[,i,])
  }
  printf("\n")
  for(i = 1 ; i<=dim; i++){
    printf("%f ",relAbund[,i,])
  }

  printf("\n")
}

define generate_powerlaw_fixed(){
  #This is the fixed version of the code. 
  if($ARGC==0){
    printf("$1 = slope\n$2 = min\n$3=max\n$4=discretization\n\n")
    return(null)
  }
  slope = float($1)
  min = float($2)
  max = float($3)
  discretization = float($4)

  radii = float(create2(min,discretization,max+discretization))

  if(max(radii)<max){
    radii = cat(radii,max,axis=y)
  }

  dim = dim(radii)[2]

  diams = radii*2.0

  cumulAbund = radii^slope

  num_in_bin = cumulAbund*0.0
  for(i = 1 ; i<dim ; i++){
    num_in_bin[,i,] = cumulAbund[,i,] - cumulAbund[,i+1,]
  }
  num_in_bin[,dim,] = 0.0

  sum = sum(num_in_bin)

  relAbund = num_in_bin/sum

  printf("%f %i\n",sum(double(relAbund)),dim)


  for(i = 1 ; i<=dim; i++){
    printf("%f ",radii[,i,])
  }
  printf("\n")
  for(i = 1 ; i<=dim; i++){
    printf("%f ",relAbund[,i,])
  }

  printf("\n")
}




define particle_size(model,fk,surfenergy,skip_phi,Nc,rc,plot,struct){
  T = $1
  TI = $2
  ks = $3
  rho = $4
  planet = $5
  cp = $6
  sample=$7

  #model options: sakatani, antwerpen, gb

  pi = 3.14159

  if(hasvalue(model)==0){
    model="sakatani"
  }
  if(hasvalue(fk)==0){
    fk=1
  }
  if(hasvalue(surfenergy)==0){
    surfenergy=0.020
  }
  if(hasvalue(skip_phi)==0){
    skip_phi=0
  }
  if(hasvalue(Nc)==0){
    define_Nc = 0
  } else {
    define_Nc = 1
  }

 if(hasvalue(rc)==0){
    define_rc = 0
  } else {
    define_rc = 1
  }

  if(hasvalue(plot)==0){
    plot = 1
  }

  if(hasvalue(struct)==0){
    struct=0
  }


  porosity = 0.4//0.5//0.6//0.7//0.8//0.9
  D = cat(1.0e-6,2.0e-6,5.0e-6,10.0e-6,20.0e-6,50.0e-6,100.0e-6,250.0e-6,500.0e-6,1.0e-3,2.0e-3,3.0e-3,5.0e-3,7.5e-3,1.0e-2,2.0e-2,3.0e-2,5.0e-2,7.5e-2,0.1,0.2,axis=x)

  phi_max = phi_max(D,planet,rho)
  phi_max[where phi_max<0.60] = 0.60

  k_out = clone(0.0,x=dim(porosity)[1],y=dim(D)[1],z=1)
  k_out_antwerp = k_out
  skin_depth = k_out

  skin_depth_violation = k_out
  phi_violation = k_out

  rho_table = k_out
  D_table = k_out
  phi_table = k_out
  TI_k = k_out


  for(i = 1 ; i<=dim(porosity)[1]; i++){

    if(define_Nc>0){
      #outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2",surfenergy=surfenergy, sample=sample,planet=planet,ks_const = ks,labfit=1,new_fk=1,suzuki=1,Nc_const = Nc)
      outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2", sample=sample,planet=planet,ks_const = ks,labfit=0,new_fk=1,suzuki=1,zeta = 0.85, xi = 0.63, surfenergy = 0.032,Nc_const = Nc)
    } else if(define_rc>0){
      #outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2",surfenergy=surfenergy, sample=sample,planet=planet,ks_const = ks,labfit=1,new_fk=1,suzuki=1,Nc_const = Nc)
      outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2", sample=sample,planet=planet,ks_const = ks,labfit=0,new_fk=1,suzuki=1,zeta = 0.85, xi = 0.63, surfenergy = 0.032,rc_fixed_ratio = rc)
    } else {
      #outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2",surfenergy=surfenergy, sample=sample,planet=planet,ks_const = ks,labfit=1,new_fk=1,suzuki=1)
      outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2", sample=sample,planet=planet,ks_const = ks,labfit=0,new_fk=1,suzuki=1,zeta = 0.85, xi = 0.63, surfenergy = 0.032)
      #outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2", sample=sample,planet=planet,ks_const = ks,labfit=0,new_fk=1,suzuki=1,zeta = 0.7, xi = 0.65, surfenergy = 0.032)
      #outd = keff(D,0.01,1.0,porosity[i,,],T,1.0e-10,1.0,(1.0-porosity[i,,])*rho,"N2", sample=sample,planet=planet,ks_const = ks,labfit=0,new_fk=1,suzuki=1,zeta = 0.96, xi = 0.30, surfenergy = 0.032)
    }




    if(model=="sakatani"){
      if(fk>0){
        k_out[i,,] = translate(outd.sakatani + outd.sakatanir*outd.fk_predicted,from=x,to=y)
      } else {
        k_out[i,,] = translate(outd.sakatani + outd.sakatanir,from=x,to=y)
      }
    } else if(model=="antwerpen"){
      if(fk>0){
        k_out[i,,] = translate(outd.kgce + outd.kr_tot*outd.fk_predicted,from=x,to=y)
      } else {
        k_out[i,,] = translate(outd.kgce + outd.kr_tot,from=x,to=y)
      }
    } else if(model=="gb"){
      if(fk>0){
        k_out[i,,] = translate(outd.GB_solid + outd.GB_rad*outd.fk_predicted,from=x,to=y)
      } else {
        k_out[i,,] = translate(outd.GB_solid + outd.GB_rad,from=x,to=y)
      }
    } else {
      printf("invalid model choice\n")
      return(0)
    }


    #k_out[i,,] = translate(outd.sakatani + outd.sakatanir,from=x,to=y)

    k_out_antwerp[i,,] = translate(outd.kgce + outd.kr_tot*outd.fk_predicted,from=x,to=y)

    rho_table[i,,] = (rho*(1.0-porosity[i,,]))
    D_table[i,,] = translate(D,from=x,to=y)
    phi_table[i,] = porosity[i,]
    TI_k[i,,] = (TI^2.0)/(rho_table[i,,]*cp)
  }

if(planet=="earth" || planet=="Earth"){
  P = 86400.0
} else if(planet == "mars" || planet == "Mars"){
  P = 88620.0
} else if(planet == "moon" || planet == "Moon"){
  P = 2.55144e6
} else if(planet == "Itokawa" || planet == "itokawa"){
  P = 43676.0
} else if(planet == "Bennu" || planet == "bennu"){
  P = 15465.8
} else if(planet == "Eros" || planet== "eros"){
  P = 18972.0
} else if(planet == "Ryugu" || planet== "ryugu"){
  P = 27457.0  
} else {
  printf("Planet not supported! Assuming Earth.\n")
  P = 86400.0
}


skin_depth = sqrt(k_out*P/(rho_table*cp*pi))
skin_depth_antwerp = sqrt(k_out*P/(rho_table*cp*pi))


skin_depth_violation[where skin_depth<D_table] = 1.0

phi_violation[where phi_table>translate(phi_max,from=y,to=x)] = 1.0



if(skip_phi==1){
  phi_violation = phi_violation*0.0
}


minpos = minpos(k_out[1,,])[2]
inters1 = interp(D[minpos:,],k_out[1,minpos:,],TI_k[1,1,],type='cubic')
minpos = minpos(k_out[2,,])[2]
inters2 = interp(D[minpos:,],k_out[2,minpos:,],TI_k[2,1,],type='cubic')
minpos = minpos(k_out[3,,])[2]
inters3 = interp(D[minpos:,],k_out[3,minpos:,],TI_k[3,1,],type='cubic')
minpos = minpos(k_out[4,,])[2]
inters4 = interp(D[minpos:,],k_out[4,minpos:,],TI_k[4,1,],type='cubic')
minpos = minpos(k_out[5,,])[2]
inters5 = interp(D[minpos:,],k_out[5,minpos:,],TI_k[5,1,],type='cubic')
minpos = minpos(k_out[6,,])[2]
inters6 = interp(D[minpos:,],k_out[6,minpos:,],TI_k[6,1,],type='cubic')


if(plot>0){
  maxdim = dim(D)[1]
  #determine ranges for plotting. 
  idx1 = int(min((find_index(phi_violation,D,1))//maxdim))
  idx2 = int(min((find_index(phi_violation,D,2))//maxdim))
  idx3 = int(min((find_index(phi_violation,D,3))//maxdim))
  idx4 = int(min((find_index(phi_violation,D,4))//maxdim))
  idx5 = int(min((find_index(phi_violation,D,5))//maxdim))
  idx6 = int(min((find_index(phi_violation,D,6))//maxdim))

  #determine ranges for plotting. 
  idx1s = int(max((find_index(skin_depth_violation,D,1))//1))
  idx2s = int(max((find_index(skin_depth_violation,D,2))//1))
  idx3s = int(max((find_index(skin_depth_violation,D,3))//1))
  idx4s = int(max((find_index(skin_depth_violation,D,4))//1))
  idx5s = int(max((find_index(skin_depth_violation,D,5))//1))
  idx6s = int(max((find_index(skin_depth_violation,D,6))//1))

  #solid line goes from 1:idxa, dashed line goes from idxb:idxc
  if(idx1<=idx1s){
    #line is truncated by porosity violation. No dashed line
    idx1a = idx1
    idx1b = 1
    idx1c = 1
  } else {
    idx1a = idx1s
    idx1b = idx1s
    idx1c = idx1
  }
  if(idx2<=idx2s){
    #line is truncated by porosity violation. No dashed line
    idx2a = idx2
    idx2b = 1
    idx2c = 1
  } else {
    idx2a = idx2s
    idx2b = idx2s
    idx2c = idx2
  }
  if(idx3<=idx3s){
    #line is truncated by porosity violation. No dashed line
    idx3a = idx3
    idx3b = 1
    idx3c = 1
  } else {
    idx3a = idx3s
    idx3b = idx3s
    idx3c = idx3
  }
  if(idx4<=idx4s){
    #line is truncated by porosity violation. No dashed line
    idx4a = idx4
    idx4b = 1
    idx4c = 1
  } else {
    idx4a = idx4s
    idx4b = idx4s
    idx4c = idx4
  }
  if(idx5<=idx5s){
    #line is truncated by porosity violation. No dashed line
    idx5a = idx5
    idx5b = 1
    idx5c = 1
  } else {
    idx5a = idx5s
    idx5b = idx5s
    idx5c = idx5
  }
  if(idx6<=idx6s){
    #line is truncated by porosity violation. No dashed line
    idx6a = idx6
    idx6b = 1
    idx6c = 1
  } else {
    idx6a = idx6s
    idx6b = idx6s
    idx6c = idx6
  }


  #solid line goes from 1:idxa, dashed line goes from idxb:idxc



  #inters1 = interp(D,k_out[1,,],TI_k[1,1,])
  #inters2 = interp(D,k_out[2,,],TI_k[2,1,])
  #inters3 = interp(D,k_out[3,,],TI_k[3,1,])
  #inters4 = interp(D,k_out[4,,],TI_k[4,1,])
  #inters5 = interp(D,k_out[5,,],TI_k[5,1,])
  #inters6 = interp(D,k_out[6,,],TI_k[6,1,])


  D = translate(log10(D),from=y,to=x)

  plot(\
  k_out[1,:idx1a,],xaxis=D[,:idx1a],color=1,width=4,style="lines",label="",\
  k_out[1,idx1b:idx1c,],xaxis=D[,idx1b:idx1c],color=1,width=1,label="",\
  k_out[2,:idx2a,],xaxis=D[,:idx2a],color=2,width=4,label="",\
  k_out[2,idx2b:idx2c,],xaxis=D[,idx2b:idx2c],color=2,width=1,label="",\
  k_out[3,:idx3a,],xaxis=D[,:idx3a],color=3,width=4,label="",\
  k_out[3,idx3b:idx3c,],xaxis=D[,idx3b:idx3c],color=3,width=1,label="",\
  k_out[4,:idx4a,],xaxis=D[,:idx4a],color=4,width=4,label="",\
  k_out[4,idx4b:idx4c,],xaxis=D[,idx4b:idx4c],color=4,width=1,label="",\
  k_out[5,:idx5a,],xaxis=D[,:idx5a],color=5,width=4,label="",\
  k_out[5,idx5b:idx5c,],xaxis=D[,idx5b:idx5c],color=5,width=1,label="",\
  k_out[6,:idx6a,],xaxis=D[,:idx6a],color=6,width=4,label="",\
  k_out[6,idx6b:idx6c,],xaxis=D[,idx6b:idx6c],color=6,width=1,label="",\
  TI_k[1,,],xaxis=D,color=1,width=4,label="",\
  TI_k[2,,],xaxis=D,color=2,width=4,label="",\
  TI_k[3,,],xaxis=D,color=3,width=4,label="",\
  TI_k[4,,],xaxis=D,color=4,width=4,label="",\
  TI_k[5,,],xaxis=D,color=5,width=4,label="",\
  TI_k[6,,],xaxis=D,color=6,width=4,label="",\
  TI_k[1,1,],xaxis=log10(inters1),style="points",color=1,width=5,label="",\
  TI_k[2,1,],xaxis=log10(inters2),style="points",color=2,width=5,label="",\
  TI_k[3,1,],xaxis=log10(inters3),style="points",color=3,width=5,label="",\
  TI_k[4,1,],xaxis=log10(inters4),style="points",color=4,width=5,label="",\
  TI_k[5,1,],xaxis=log10(inters5),style="points",color=5,width=5,label="",\
  TI_k[6,1,],xaxis=log10(inters6),style="points",color=6,width=5,label="")
}

if(struct>0){
  out = {}
  out.inters = inters1//inters2//inters3//inters4//inters5//inters6
  out.skin_depth = skin_depth_violation
  out.phi = phi_violation
  out.D = D
  return(out)
} else {
  return(inters1//inters2//inters3//inters4//inters5//inters6)
}


}

define find_index(){
  phi_violation = $1
  D = $2
  col = $3
  #determine ranges for plotting. 
  idx = 0
  i=1
  while(idx<1 && i<=dim(D)[1]){
    if(phi_violation[col,i,]>0){
      idx = i
    }
    i++
  }
  if(idx<1){
    idx = dim(D)[1]
  }
  return(idx)
}



define particle_range(){
  model = $1
  fk = $2
  ks = 1.0//0.75//0.5//0.4//0.3//0.2//0.15//0.125//0.1//0.09//0.08//0.07//0.06//0.05//0.04//0.03//0.02//0.01
  out = ks*0.0
  model
  for(i = 1; i<= dim(ks)[1] ; i++){
    result = particle_size(330.0,200.0,ks[i,,],2130.0,"Bennu",1000.0,"tagish",model=model,fk=fk)
    out[i,,] = result[1,,]

  }
return(translate(out,from=y,to=x))

}

define TI_range(){
  model = $1
  ks = $2
  fk = 1
  TI= 50.0//75.0//100.0//125.0//150.0//175.0//200.0
  out = TI*0.0
  model
  for(i = 1; i<= dim(TI)[1] ; i++){
    result = particle_size(330.0,TI[i,,],ks,2130.0,"Bennu",900.0,"tagish",model=model,fk=1)
    out[i,,] = result[1,,]
    pause()

  }
return(translate(out,from=y,to=x))

}

